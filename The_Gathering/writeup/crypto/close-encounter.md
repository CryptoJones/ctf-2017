# Close Encounter

> Points: 125
> 
> Author: PewZ
> 
> We intercepted this RSA encrypted message. Can you decrypt it for us?
> 
> ciphertext: 3301725813323793523830449827529001764170324266525813942905248339398533386704146778215164605307364778538312368834939155244976282618558606453065237517755562156941816361506386129237655201821569225442531883605299886901781519717
> n = 647580559066350764512574139212258654419619377791696792933162647847016182264786947024323483613445156926567953673211035865775396889491136493021394983865794529477091872229948860215774356455333826515720143910504339782998354975787558272036453370109286642626999091302012693562994565167763421804705602666440082138719409120664293876204553614511882382199434919365954997082834057119072868066696185230896273866269308019520562618860020221768639470528300841159704088859374399286986458302241337120121430937058280863472916553328255990461105886678126859657320418919609691089677744300138990131567897731188913573095161012997609872471436323858576012929455006921387033623358406327954425701649820631580290471076284227572599505740170534938538303275799383217459413578897504327360744415747939112249827320135553789275968404788584789483305709222531189435482276931098037440920811828069795012367922134191531348046137386595744872323763751900274523135348273825558806037832123609238684829315071013742451094194097286985647180549444633529585827947422469423955056342229557961062943802754823402381380268562309956425582717559687406317915547051766896665477764999756658000565784673316779579644624160889528487904071313946671365415309957045804828537561845474437630201414013
> e = 3


The RSA cryptosystem works in the following manner:

Encryption:
__*c = m^e mod n*__

Decryption:
__*m = c^d mod n*__

Where __*n = pq*__, where __*p*__ and __*q*__ are prime, __*f = (p - 1)(q - 1) mod n*__, and __*d*__ such that __*ed = 1 (mod f)*__
The strength of RSA is the fact that factorization of __*n*__ into __*p*__ and __*q*__ is hard (computationally infeasible).

There are a number of pitfalls, that all result in RSA that can be cracked. They all leverage the fact that poor RSA parameters were chosen.

For one, we see that __*n*__ is large, while __*c*__ seem to be small in relation to them.
We also have a small __*e*__, which in conjunciton with a small plaintext can be an issue.
It is not sufficient for __*n*__ to be large, but it's prime factors to be relatively far from each other.

If __*e*__ and __*m*__ are sufficiently small, and the message is not padded sufficiently, a low public exponent attack can be mounted.
But if the prime factors __*p*__ and __*q*__ are too close, Fermat factorization be speed up factorization greatly.

## Low public exponent

In this case, __*e*__ is the smallest possible number that can be used. Because we also see a very small cipher $$c$$, and we expect the plaintext to be short, and it might not be padded sufficiently.

If the following must holds; we can apply a simple low public exponent attack:

__*m < epsilon\*n, epsilon is small, epsilon is a natural number*__

If this is true, we can crack the cipher by exploiting:

__*c = m^e mod n -> m^e < epsilon\*n, epsilon is small due to the small e*__

Leading to:

__*m = (c + epsilon\*n)^(1/3), epsilon is a natural number*__
The cracking can be done by computing:

__*m = (c + epsilon\*n)^(1/3), epsilon in {0, 1, 2, 3, ...}*__

And stop once a message $$m$$ is discovered such that:

__*m^3 =c*__

Which mean that the correct __*m*__ is discovered, and the RSA encryption is cracked.

This can be solved in the following manner:

```python
import gmpy
import binascii

c = 3301725813323793523830449827529001764170324266525813942905248339398533386704146778215164605307364778538312368834939155244976282618558606453065237517755562156941816361506386129237655201821569225442531883605299886901781519717
n = 647580559066350764512574139212258654419619377791696792933162647847016182264786947024323483613445156926567953673211035865775396889491136493021394983865794529477091872229948860215774356455333826515720143910504339782998354975787558272036453370109286642626999091302012693562994565167763421804705602666440082138719409120664293876204553614511882382199434919365954997082834057119072868066696185230896273866269308019520562618860020221768639470528300841159704088859374399286986458302241337120121430937058280863472916553328255990461105886678126859657320418919609691089677744300138990131567897731188913573095161012997609872471436323858576012929455006921387033623358406327954425701649820631580290471076284227572599505740170534938538303275799383217459413578897504327360744415747939112249827320135553789275968404788584789483305709222531189435482276931098037440920811828069795012367922134191531348046137386595744872323763751900274523135348273825558806037832123609238684829315071013742451094194097286985647180549444633529585827947422469423955056342229557961062943802754823402381380268562309956425582717559687406317915547051766896665477764999756658000565784673316779579644624160889528487904071313946671365415309957045804828537561845474437630201414013

m = gmpy.root(c, 3)[0]

# Stop once we reach the correct message, m
while pow(m, 3, n) != c:
    m = gmpy.root(c + n, 3)[0]

# Print the message in a more convenient format
print(binascii.unhexlify(hex(m)[2:]))
```

Which will yield the flag: __`TG17{t00_cl0se_f0r_g00d_crypt0}`__.

## Fermat factorization

Fermat factorization exploit the difference between __*p*__ and __*q*__ being small to greatly reduce the amount of time required to factorize __*n*__, which in turn will be used to compute the secret, __*d*__.

In particular, it is based on the representation of an odd integer as the difference of two squares:

__*n = x^2 - y^2*__

and in particular, if __*n = pq*__ we have:

__*n = ((p + q)/(2))^2 - ((p - q)/(2))^2*__

In practice, we can try different values of __*x*__, hoping that __*x^2 - n = y^2*__ is a square, meaning __*y*__ is an integer.
This mean that we can start out by trying __*x = n^(1/2)*__, and if __*x^2 - n = y^2*__ is not a square, increment __*x*__.
Continue this until a suitable __*x*__ is discovered, upon which the factors are __*x -y*__ and __*x + y*__.

This can be computed by the following sage function:

```python
def fermat(n):
     a = ceil(sqrt(n))
     b_sq = (a * a) - n
     while int(sqrt(b_sq))**2 != b_sq:
         a += 1
         b_sq = (a * a) - n
     return a - sqrt(b_sq)
```

This can be used to factor __*n*__ into __*q*__ and __*p*__, which can be used to decrypt the message:

```python
n = 647580559066350764512574139212258654419619377791696792933162647847016182264786947024323483613445156926567953673211035865775396889491136493021394983865794529477091872229948860215774356455333826515720143910504339782998354975787558272036453370109286642626999091302012693562994565167763421804705602666440082138719409120664293876204553614511882382199434919365954997082834057119072868066696185230896273866269308019520562618860020221768639470528300841159704088859374399286986458302241337120121430937058280863472916553328255990461105886678126859657320418919609691089677744300138990131567897731188913573095161012997609872471436323858576012929455006921387033623358406327954425701649820631580290471076284227572599505740170534938538303275799383217459413578897504327360744415747939112249827320135553789275968404788584789483305709222531189435482276931098037440920811828069795012367922134191531348046137386595744872323763751900274523135348273825558806037832123609238684829315071013742451094194097286985647180549444633529585827947422469423955056342229557961062943802754823402381380268562309956425582717559687406317915547051766896665477764999756658000565784673316779579644624160889528487904071313946671365415309957045804828537561845474437630201414013
c = 3301725813323793523830449827529001764170324266525813942905248339398533386704146778215164605307364778538312368834939155244976282618558606453065237517755562156941816361506386129237655201821569225442531883605299886901781519717
e = 3


p = fermat(n)
q = n/p
phi = (p-1)*(q-1)
d = inverse_mod(e, phi)
m = pow(c, d, n)

print binascii.unhexlify(hex(Integer(m))
```

Yielding the flag: __`TG17{t00_cl0se_f0r_g00d_crypt0}`__.
